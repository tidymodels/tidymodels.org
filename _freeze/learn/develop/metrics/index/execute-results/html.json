{
  "hash": "1409dd6805f2202af9de8ff823f12965",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Custom performance metrics\"\ncategories:\n  - developer tools\ntype: learn-subsection\nweight: 3\ndescription: | \n  Create a new performance metric and integrate it with yardstick functions.\ntoc: true\ntoc-depth: 2\ninclude-after-body: ../../../resources.html\n---\n\n\n\n\n\n\n\n\n## Introduction\n\nTo use code in this article,  you will need to install the following packages: rlang and tidymodels.\n\nThe [yardstick](https://yardstick.tidymodels.org/) package already includes a large number of metrics, but there's obviously a chance that you might have a custom metric that hasn't been implemented yet. In that case, you can use a few of the tools yardstick exposes to create custom metrics.\n\nWhy create custom metrics? With the infrastructure yardstick provides, you get:\n\n-   Standardization between your metric and other preexisting metrics\n-   Automatic error handling for types and lengths\n-   Automatic selection of binary / multiclass metric implementations\n-   Support for `NA` handling\n-   Support for grouped data frames\n-   Support for use alongside other metrics in `metric_set()`\n\nThe implementation for metrics differ slightly depending on whether you are implementing a numeric, class, or class probability metric. Examples for numeric and classification metrics are given below. We would encourage you to look into the implementation of `roc_auc()` after reading this vignette if you want to work on a class probability metric.\n\n## Numeric example: MSE\n\nMean squared error (sometimes MSE or from here on, `mse()`) is a numeric metric that measures the average of the squared errors. Numeric metrics are generally the simplest to create with yardstick, as they do not have multiclass implementations. The formula for `mse()` is:\n\n$$ MSE = \\frac{1}{N} \\sum_{i=1}^{N} (truth_i - estimate_i) ^ 2 = mean( (truth - estimate) ^ 2) $$\n\nAll metrics should have a data frame version, and a vector version. The data frame version here will be named `mse()`, and the vector version will be `mse_vec()`.\n\n### Vector implementation\n\nTo start, create the vector version. Generally, all metrics have the same arguments unless the metric requires an extra parameter (such as `beta` in `f_meas()`). To create the vector function, you need to do two things:\n\n1)  Create an internal implementation function, `mse_impl()`.\n2)  Use that implementation function with `check_class_metric()`/`check_numeric_metric()`/`check_prob_metric()`, `yardstick_remove_missing()`, and `and yardstick_any_missing()`.\n\nBelow, `mse_impl()` contains the actual implementation of the metric, and takes `truth` and `estimate` as arguments along with any metric specific arguments. Optionally `case_weights` if the calculations supports it.\n\nThe yardstick function `check_numeric_metric()` takes `truth`, `estimate` and `case_weights`, and validates that they are the right type, and are the same length.\n\nThe `yardstick_remove_missing()` and `yardstick_any_missing()` yardstick functions are used to handle missing values in a consistent way, similarly to how the other metrics handle them. The code below is typically copy pasted from function to function, but certain types of metrics might want to deviate from this pattern.\n\nYou are required to supply a `case_weights` argument to `mse_vec()` for the functions to work with yardstick. If your metric in question doesn't support case weights, you can error if they are passed, or simply ignore it.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(tidymodels)\n\nmse_impl <- function(truth, estimate, case_weights = NULL) {\n  mean((truth - estimate) ^ 2)\n}\n\nmse_vec <- function(truth, estimate, na_rm = TRUE, case_weights = NULL, ...) {\n  check_numeric_metric(truth, estimate, case_weights)\n\n  if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  mse_impl(truth, estimate, case_weights = case_weights)\n}\n```\n:::\n\n\n\n\nAt this point, you've created the vector version of the mean squared error metric.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(\"solubility_test\")\n\nmse_vec(\n  truth = solubility_test$solubility, \n  estimate = solubility_test$prediction\n)\n#> [1] 0.5214438\n```\n:::\n\n\n\n\nIntelligent error handling is immediately available.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmse_vec(truth = \"apple\", estimate = 1)\n#> Error in `mse_vec()`:\n#> ! `truth` should be a numeric vector, not a string.\n\nmse_vec(truth = 1, estimate = factor(\"xyz\"))\n#> Error in `mse_vec()`:\n#> ! `estimate` should be a numeric vector, not a <factor>\n#>   object.\n```\n:::\n\n\n\n\n`NA` values are removed if `na_rm = TRUE` (the default). If `na_rm = FALSE` and any `NA` values are detected, then the metric automatically returns `NA`.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# NA values removed\nmse_vec(truth = c(NA, .5, .4), estimate = c(1, .6, .5))\n#> [1] 0.01\n\n# NA returned\nmse_vec(truth = c(NA, .5, .4), estimate = c(1, .6, .5), na_rm = FALSE)\n#> [1] NA\n```\n:::\n\n\n\n\n### Data frame implementation\n\nThe data frame version of the metric should be fairly simple. It is a generic function with a `data.frame` method that calls the yardstick helper, `numeric_metric_summarizer()`, and passes along the `mse_vec()` function to it along with versions of `truth` and `estimate` that have been wrapped in `rlang::enquo()` and then unquoted with `!!` so that non-standard evaluation can be supported.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(rlang)\n\nmse <- function(data, ...) {\n  UseMethod(\"mse\")\n}\n\nmse <- new_numeric_metric(mse, direction = \"minimize\")\n\nmse.data.frame <- function(data, truth, estimate, na_rm = TRUE, case_weights = NULL, ...) {\n\n  numeric_metric_summarizer(\n    name = \"mse\",\n    fn = mse_vec,\n    data = data,\n    truth = !!enquo(truth),\n    estimate = !!enquo(estimate),\n    na_rm = na_rm,\n    case_weights = !!enquo(case_weights)\n  )\n}\n```\n:::\n\n\n\n\nAnd that's it. The yardstick package handles the rest.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmse(solubility_test, truth = solubility, estimate = prediction)\n\n# Error handling\nmse(solubility_test, truth = solubility, estimate = factor(\"xyz\"))\n```\n:::\n\n\n\n\nLet's test it out on a grouped data frame.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nset.seed(1234)\nsize <- 100\ntimes <- 10\n\n# create 10 resamples\nsolubility_resampled <- bind_rows(\n  replicate(\n    n = times,\n    expr = sample_n(solubility_test, size, replace = TRUE),\n    simplify = FALSE\n  ),\n  .id = \"resample\"\n)\n\nsolubility_resampled %>%\n  group_by(resample) %>%\n  mse(solubility, prediction)\n#> # A tibble: 10 × 4\n#>    resample .metric .estimator .estimate\n#>    <chr>    <chr>   <chr>          <dbl>\n#>  1 1        mse     standard       0.512\n#>  2 10       mse     standard       0.454\n#>  3 2        mse     standard       0.513\n#>  4 3        mse     standard       0.414\n#>  5 4        mse     standard       0.543\n#>  6 5        mse     standard       0.456\n#>  7 6        mse     standard       0.652\n#>  8 7        mse     standard       0.642\n#>  9 8        mse     standard       0.404\n#> 10 9        mse     standard       0.479\n```\n:::\n\n\n\n\n## Class example: miss rate\n\nMiss rate is another name for the false negative rate, and is a classification metric in the same family as `sens()` and `spec()`. It follows the formula:\n\n$$ miss\\_rate = \\frac{FN}{FN + TP} $$\n\nThis metric, like other classification metrics, is more easily computed when expressed as a confusion matrix. As you will see in the example, you can achieve this with a call to `base::table(estimate, truth)` which correctly puts the \"correct\" result in the columns of the confusion matrix.\n\nClassification metrics are more complicated than numeric ones because you have to think about extensions to the multiclass case. For now, let's start with the binary case.\n\n### Vector implementation\n\nThe vector implementation for classification metrics initially has a very similar setup as the numeric metrics. It used `check_class_metric()` instead of `check_numeric_metric()`. It has an additional argument, `estimator` that determines the type of estimator to use (binary or some kind of multiclass implementation or averaging). This argument is auto-selected for the user, so default it to  `NULL`. Additionally, pass it along to `check_class_metric()` so that it can check the provided `estimator` against the classes of `truth` and `estimate` to see if they are allowed.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Logic for `event_level`\nevent_col <- function(xtab, event_level) {\n  if (identical(event_level, \"first\")) {\n    colnames(xtab)[[1]]\n  } else {\n    colnames(xtab)[[2]]\n  }\n}\n\nmiss_rate_impl <- function(truth, estimate, event_level) {\n  # Create \n  xtab <- table(estimate, truth)\n  col <- event_col(xtab, event_level)\n  col2 <- setdiff(colnames(xtab), col)\n\n  tp <- xtab[col, col]\n  fn <- xtab[col2, col]\n\n  fn / (fn + tp)\n}\n\nmiss_rate_vec <- function(truth,\n                          estimate,\n                          estimator = NULL,\n                          na_rm = TRUE,\n                          case_weights = NULL,\n                          event_level = \"first\",\n                          ...) {\n  estimator <- finalize_estimator(truth, estimator)\n\n  check_class_metric(truth, estimate, case_weights, estimator)\n  \n    if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  miss_rate_impl(truth, estimate, event_level)\n}\n```\n:::\n\n\n\n\nAnother change from the numeric metric is that a call to `finalize_estimator()` is made. This is the infrastructure that auto-selects the type of estimator to use.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(\"two_class_example\")\nmiss_rate_vec(two_class_example$truth, two_class_example$predicted)\n#> [1] 0.120155\n```\n:::\n\n\n\n\nWhat happens if you try and pass in a multiclass result?\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(\"hpc_cv\")\nfold1 <- filter(hpc_cv, Resample == \"Fold01\")\nmiss_rate_vec(fold1$obs, fold1$pred)\n#>          F          M          L \n#> 0.06214689 0.00000000 0.00000000\n```\n:::\n\n\n\n\nThis isn't great, as currently multiclass `miss_rate()` isn't supported and it would have been better to throw an error if the `estimator` was not `\"binary\"`. Currently, `finalize_estimator()` uses its default implementation which selected `\"macro\"` as the `estimator` since `truth` was a factor with more than 2 classes. When we implement multiclass averaging, this is what you want, but if your metric only works with a binary implementation (or has other specialized multiclass versions), you might want to guard against this.\n\nTo fix this, a generic counterpart to `finalize_estimator()`, called `finalize_estimator_internal()`, exists that helps you restrict the input types. If you provide a method to `finalize_estimator_internal()` where the method name is the same as your metric name, and then set the `metric_class` argument in `finalize_estimator()` to be the same thing, you can control how the auto-selection of the `estimator` is handled.\n\nDon't worry about the `metric_dispatcher` argument. This is handled for you and just exists as a dummy argument to dispatch off of.\n\nIt is also good practice to call `validate_estimator()` which handles the case where a user passed in the estimator themselves. This validates that the supplied `estimator` is one of the allowed types and error otherwise.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfinalize_estimator_internal.miss_rate <- function(metric_dispatcher, x, estimator, call) {\n  \n  validate_estimator(estimator, estimator_override = \"binary\")\n  if (!is.null(estimator)) {\n    return(estimator)\n  }\n  \n  lvls <- levels(x)\n  if (length(lvls) > 2) {\n    stop(\"A multiclass `truth` input was provided, but only `binary` is supported.\")\n  } \n  \"binary\"\n}\n\nmiss_rate_vec <- function(truth,\n                          estimate,\n                          estimator = NULL,\n                          na_rm = TRUE,\n                          case_weights = NULL,\n                          event_level = \"first\",\n                          ...) {\n  # calls finalize_estimator_internal() internally\n  estimator <- finalize_estimator(truth, estimator, metric_class = \"miss_rate\")\n  \n  check_class_metric(truth, estimate, case_weights, estimator)\n  \n  if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  miss_rate_impl(truth, estimate, event_level)\n}\n\n# Error thrown by our custom handler\n# miss_rate_vec(fold1$obs, fold1$pred)\n\n# Error thrown by validate_estimator()\n# miss_rate_vec(fold1$obs, fold1$pred, estimator = \"macro\")\n```\n:::\n\n\n\n\n### Supporting multiclass miss rate\n\nLike many other classification metrics such as `precision()` or `recall()`, miss rate does not have a natural multiclass extension, but one can be created using methods such as macro, weighted macro, and micro averaging. If you have not, I encourage you to read `vignette(\"multiclass\", \"yardstick\")` for more information about how these methods work.\n\nGenerally, they require more effort to get right than the binary case, especially if you want to have a performant version. Luckily, a somewhat standard template is used in yardstick and can be used here as well.\n\nLet's first remove the \"binary\" restriction we created earlier.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nrm(finalize_estimator_internal.miss_rate)\n```\n:::\n\n\n\n\nThe main changes below are:\n\n-   The binary implementation is moved to `miss_rate_binary()`.\n\n-   `miss_rate_estimator_impl()` is a helper function for switching between binary and multiclass implementations. It also applies the weighting required for multiclass estimators. It is called from `miss_rate_impl()` and also accepts the `estimator` argument using R's function scoping rules.\n\n-   `miss_rate_multiclass()` provides the implementation for the multiclass case. It calculates the true positive and false negative values as vectors with one value per class. For the macro case, it returns a vector of miss rate calculations, and for micro, it first sums the individual pieces and returns a single miss rate calculation. In the macro case, the vector is then weighted appropriately in `miss_rate_estimator_impl()` depending on whether or not it was macro or weighted macro.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmiss_rate_vec <- function(truth, \n                          estimate, \n                          estimator = NULL, \n                          na_rm = TRUE, \n                          case_weights = NULL,\n                          event_level = \"first\",\n                          ...) {\n  # calls finalize_estimator_internal() internally\n  estimator <- finalize_estimator(truth, estimator, metric_class = \"miss_rate\")\n  \n  check_class_metric(truth, estimate, case_weights, estimator)\n  \n  if (na_rm) {\n    result <- yardstick_remove_missing(truth, estimate, case_weights)\n\n    truth <- result$truth\n    estimate <- result$estimate\n    case_weights <- result$case_weights\n  } else if (yardstick_any_missing(truth, estimate, case_weights)) {\n    return(NA_real_)\n  }\n\n  miss_rate_impl(truth, estimate, estimator, event_level)\n}\n\nmiss_rate_impl <- function(truth, estimate, estimator, event_level) {\n  xtab <- table(estimate, truth)\n  # Rather than implement the actual method here, we rely on\n  # an *_estimator_impl() function that can handle binary\n  # and multiclass cases\n  miss_rate_estimator_impl(xtab, estimator, event_level)\n}\n\n# This function switches between binary and multiclass implementations\nmiss_rate_estimator_impl <- function(data, estimator, event_level) {\n  if(estimator == \"binary\") {\n    miss_rate_binary(data, event_level)\n  } else {\n    # Encapsulates the macro, macro weighted, and micro cases\n    wt <- get_weights(data, estimator)\n    res <- miss_rate_multiclass(data, estimator)\n    weighted.mean(res, wt)\n  }\n}\n\n\nmiss_rate_binary <- function(data, event_level) {\n  col <- event_col(data, event_level)\n  col2 <- setdiff(colnames(data), col)\n  \n  tp <- data[col, col]\n  fn <- data[col2, col]\n  \n  fn / (fn + tp)\n}\n\nmiss_rate_multiclass <- function(data, estimator) {\n  \n  # We need tp and fn for all classes individually\n  # we can get this by taking advantage of the fact\n  # that tp + fn = colSums(data)\n  tp <- diag(data)\n  tpfn <- colSums(data)\n  fn <- tpfn - tp\n  \n  # If using a micro estimator, we sum the individual\n  # pieces before performing the miss rate calculation\n  if (estimator == \"micro\") {\n    tp <- sum(tp)\n    fn <- sum(fn)\n  }\n  \n  # return the vector \n  tp / (tp + fn)\n}\n```\n:::\n\n\n\n\nFor the macro case, this separation of weighting from the core implementation might seem strange, but there is good reason for it. Some metrics are combinations of other metrics, and it is nice to be able to reuse code when calculating more complex metrics. For example, `f_meas()` is a combination of `recall()` and `precision()`. When calculating a macro averaged `f_meas()`, the weighting must be applied 1 time, at the very end of the calculation. `recall_multiclass()` and `precision_multiclass()` are defined similarly to how `miss_rate_multiclass()` is defined and returns the unweighted vector of calculations. This means we can directly use this in `f_meas()`, and then weight everything once at the end of that calculation.\n\nLet's try it out now:\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# two class\nmiss_rate_vec(two_class_example$truth, two_class_example$predicted)\n#> [1] 0.120155\n\n# multiclass\nmiss_rate_vec(fold1$obs, fold1$pred)\n#> [1] 0.5483506\n```\n:::\n\n\n\n\n#### Data frame implementation\n\nLuckily, the data frame implementation is as simple as the numeric case, we just need to add an extra `estimator` argument and pass that through.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmiss_rate <- function(data, ...) {\n  UseMethod(\"miss_rate\")\n}\n\nmiss_rate <- new_class_metric(miss_rate, direction = \"minimize\")\n\nmiss_rate.data.frame <- function(data, \n                                 truth, \n                                 estimate, \n                                 estimator = NULL, \n                                 na_rm = TRUE, \n                                 case_weights = NULL,\n                                 event_level = \"first\",\n                                 ...) {\n  class_metric_summarizer(\n    name = \"miss_rate\",\n    fn = miss_rate_vec,\n    data = data,\n    truth = !!enquo(truth),\n    estimate = !!enquo(estimate), \n    estimator = estimator,\n    na_rm = na_rm,\n    case_weights = !!enquo(case_weights),\n    event_level = event_level\n  )\n}\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Macro weighted automatically selected\nfold1 %>%\n  miss_rate(obs, pred)\n\n# Switch to micro\nfold1 %>%\n  miss_rate(obs, pred, estimator = \"micro\")\n\n# Macro weighted by resample\nhpc_cv %>%\n  group_by(Resample) %>%\n  miss_rate(obs, pred, estimator = \"macro_weighted\")\n\n# Error handling\nmiss_rate(hpc_cv, obs, VF)\n```\n:::\n\n\n\n\n## Using custom metrics\n\nThe `metric_set()` function validates that all metric functions are of the same metric type by checking the class of the function. If any metrics are not of the right class, `metric_set()` fails. By using `new_numeric_metric()` and `new_class_metric()` in the above custom metrics, they work out of the box without any additional adjustments.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnumeric_mets <- metric_set(mse, rmse)\n\nnumeric_mets(solubility_test, solubility, prediction)\n#> # A tibble: 2 × 3\n#>   .metric .estimator .estimate\n#>   <chr>   <chr>          <dbl>\n#> 1 mse     standard       0.521\n#> 2 rmse    standard       0.722\n```\n:::\n\n\n\n\n## Session information {#session-info}\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```\n#> ─ Session info ─────────────────────────────────────────────────────\n#>  version  R version 4.4.2 (2024-10-31)\n#>  language (EN)\n#>  date     2025-03-24\n#>  pandoc   3.6.1\n#>  quarto   1.6.42\n#> \n#> ─ Packages ─────────────────────────────────────────────────────────\n#>  package      version date (UTC) source\n#>  broom        1.0.7   2024-09-26 CRAN (R 4.4.1)\n#>  dials        1.4.0   2025-02-13 CRAN (R 4.4.2)\n#>  dplyr        1.1.4   2023-11-17 CRAN (R 4.4.0)\n#>  ggplot2      3.5.1   2024-04-23 CRAN (R 4.4.0)\n#>  infer        1.0.7   2024-03-25 CRAN (R 4.4.0)\n#>  parsnip      1.3.1   2025-03-12 CRAN (R 4.4.1)\n#>  purrr        1.0.4   2025-02-05 CRAN (R 4.4.1)\n#>  recipes      1.2.0   2025-03-17 CRAN (R 4.4.1)\n#>  rlang        1.1.5   2025-01-17 CRAN (R 4.4.2)\n#>  rsample      1.2.1   2024-03-25 CRAN (R 4.4.0)\n#>  tibble       3.2.1   2023-03-20 CRAN (R 4.4.0)\n#>  tidymodels   1.3.0   2025-02-21 CRAN (R 4.4.1)\n#>  tune         1.3.0   2025-02-21 CRAN (R 4.4.1)\n#>  workflows    1.2.0   2025-02-19 CRAN (R 4.4.1)\n#>  yardstick    1.3.2   2025-01-22 CRAN (R 4.4.1)\n#> \n#> ────────────────────────────────────────────────────────────────────\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}