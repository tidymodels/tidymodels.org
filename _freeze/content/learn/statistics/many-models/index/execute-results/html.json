{
  "hash": "8b507d2b8c5252519f803be34ba5a47b",
  "result": {
    "markdown": "---\ntitle: \"Many Models\"\ncategories:\n  - statistical analysis\n  - tidying results\ntype: learn-subsection\nweight: 1\ndescription: | \n  Analyze the results of many linear regressions and learn about nested data frames along the way.\n---\n\n\n\n\n\n\n\n_These materials were in the first edition of [R for Data Science](https://r4ds.had.co.nz). They are not in later editions and are shown here -- with some modifications-- with permission_. To use code in this article,  you will need to install the following packages: gapminder, stringr, and tidymodels.\n\nIn this article, you're going to learn three powerful ideas that help you to work with large numbers of models with ease:\n\n1.  Using many simple models to better understand complex datasets.\n\n1.  Using list-columns to store arbitrary data structures in a data frame.\n    For example, this will allow you to have a column that contains linear \n    models.\n   \n1.  Using the __broom__ package, originally by David Robinson, to turn models into tidy \n    data. This is a powerful technique for working with large numbers of models.\n\nWe'll start by diving into a motivating example using data about life expectancy around the world. It's a small dataset but it illustrates how important modelling can be for improving your visualisations. We'll use a large number of simple models to partition out some of the strongest signals so we can see the subtler signals that remain. We'll also see how model summaries can help us pick out outliers and unusual trends.\n\nThe following sections will dive into more detail about the individual techniques:\n\n1. In [list-columns], you'll learn more about the list-column data structure,\n   and why it's valid to put lists in data frames.\n   \n1. In [creating list-columns], you'll learn the three main ways in which you'll\n   create list-columns.\n   \n1. In [simplifying list-columns] you'll learn how to convert list-columns back\n   to regular atomic vectors (or sets of atomic vectors) so you can work\n   with them more easily.\n   \n1. In [making tidy data with broom], you'll learn about the full set of tools\n   provided by broom, and see how they can be applied to other types of \n   data structure.\n\nFirst, let's load some packages:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-3_68b436f9fd1b8a93a8377ef202bb7c9c'}\n\n```{.r .cell-code}\nlibrary(tidymodels)\ntidymodels_prefer()\n```\n:::\n\n\n## gapminder\n\nTo motivate the power of many simple models, we're going to look into the \"gapminder\" data. This data was popularised by Hans Rosling, a Swedish doctor and statistician. If you've never heard of him, stop reading this chapter right now and go watch one of his videos! He is a fantastic data presenter and illustrates how you can use data to present a compelling story. A good place to start is this short video filmed in conjunction with the BBC: <https://www.youtube.com/watch?v=jbkSRLYSojo>.\n\nThe gapminder data summarises the progression of countries over time, looking at statistics like life expectancy and GDP. The data is easy to access in R, thanks to Jenny Bryan who created the gapminder package:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-4_61bfa05dd2f83dae069375d16a77211a'}\n\n```{.r .cell-code}\nlibrary(gapminder)\ngapminder\n#> # A tibble: 1,704 × 6\n#>    country     continent  year lifeExp      pop gdpPercap\n#>    <fct>       <fct>     <int>   <dbl>    <int>     <dbl>\n#>  1 Afghanistan Asia       1952    28.8  8425333      779.\n#>  2 Afghanistan Asia       1957    30.3  9240934      821.\n#>  3 Afghanistan Asia       1962    32.0 10267083      853.\n#>  4 Afghanistan Asia       1967    34.0 11537966      836.\n#>  5 Afghanistan Asia       1972    36.1 13079460      740.\n#>  6 Afghanistan Asia       1977    38.4 14880372      786.\n#>  7 Afghanistan Asia       1982    39.9 12881816      978.\n#>  8 Afghanistan Asia       1987    40.8 13867957      852.\n#>  9 Afghanistan Asia       1992    41.7 16317921      649.\n#> 10 Afghanistan Asia       1997    41.8 22227415      635.\n#> # … with 1,694 more rows\n```\n:::\n\n\nIn this case study, we're going to focus on just three variables to answer the question \"How does life expectancy (`lifeExp`) change over time (`year`) for each country (`country`)?\". A good place to start is with a plot:\n\n\n::: {.cell layout-align=\"center\" hash='cache/year-life-exp_2ae61e7d6272489aa9ea110790fd6fc6'}\n\n```{.r .cell-code}\ngapminder %>% \n  ggplot(aes(year, lifeExp, group = country)) +\n    geom_line(alpha = 1/3)\n```\n\n::: {.cell-output-display}\n![](figs/year-life-exp-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\nThis is a small dataset: it only has ~1,700 observations and 3 variables. But it's still hard to see what's going on! Overall, it looks like life expectancy has been steadily improving. However, if you look closely, you might notice some countries that don't follow this pattern. How can we make those countries easier to see?\n\nOne way is to use the same approach as in the last chapter: there's a strong signal (overall linear growth) that makes it hard to see subtler trends. We'll tease these factors apart by fitting a model with a linear trend. The model captures steady growth over time, and the residuals will show what's left.\n\nYou already know how to do that if we had a single country:\n\n\n::: {.cell layout-align=\"center\" fig.asp='1' hash='cache/year-life-exp-nz_06fcd418a5a9e9d7c356ed3c88d34748'}\n\n```{.r .cell-code}\nnz <- filter(gapminder, country == \"New Zealand\")\nnz %>% \n  ggplot(aes(year, lifeExp)) + \n  geom_line() + \n  ggtitle(\"Full data = \")\n```\n\n::: {.cell-output-display}\n![](figs/year-life-exp-nz-1.svg){fig-align='center' width=33%}\n:::\n\n```{.r .cell-code}\n\nnz_mod <- lm(lifeExp ~ year, data = nz)\n```\n:::\n\n\nThe broom package provides a general set of functions to turn models into tidy data. One function, `augment()`, is used to supplement a data set with columns such as the predicted values, residuals, and so on. We'll use this to plot the predicted versus observed data: \n\n\n::: {.cell layout-align=\"center\" hash='cache/year-life-exp-nz-resid_6f887ff3d02adfedd7ea443d09af9830'}\n\n```{.r .cell-code}\nnz_mod_res <- augment(nz_mod)\n\nnz_mod_res %>%\n  ggplot(aes(year, .fitted)) + \n  geom_line() + \n  ggtitle(\"Linear trend + \")\n```\n\n::: {.cell-output-display}\n![](figs/year-life-exp-nz-resid-1.svg){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\n\nnz_mod_res %>% \n  ggplot(aes(year, .resid)) + \n  geom_hline(yintercept = 0, colour = \"white\", linewidth = 3) + \n  geom_line() + \n  ggtitle(\"Remaining pattern\")\n```\n\n::: {.cell-output-display}\n![](figs/year-life-exp-nz-resid-2.svg){fig-align='center' width=672}\n:::\n:::\n\n\nThere is a `data` argument to `augment()`. The default uses the same data points that the model was trained on.  \n\nHow can we easily fit that model to every country?\n\n### Nested data\n\nYou could imagine copy and pasting that code multiple times; but you've already learned a better way! Extract out the common code with a function and repeat using a map function from purrr. This problem is structured a little differently to what you've seen before. Instead of repeating an action for each variable, we want to repeat an action for each country, a subset of rows. To do that, we need a new data structure: the __nested data frame__. To create a nested data frame we start with a grouped data frame, and \"nest\" it:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-8_cc1ce25bb88024098422348cd2fe7ee9'}\n\n```{.r .cell-code}\nby_country <- gapminder %>% \n  group_by(country, continent) %>% \n  nest()\n\nby_country\n#> # A tibble: 142 × 3\n#> # Groups:   country, continent [142]\n#>    country     continent data             \n#>    <fct>       <fct>     <list>           \n#>  1 Afghanistan Asia      <tibble [12 × 4]>\n#>  2 Albania     Europe    <tibble [12 × 4]>\n#>  3 Algeria     Africa    <tibble [12 × 4]>\n#>  4 Angola      Africa    <tibble [12 × 4]>\n#>  5 Argentina   Americas  <tibble [12 × 4]>\n#>  6 Australia   Oceania   <tibble [12 × 4]>\n#>  7 Austria     Europe    <tibble [12 × 4]>\n#>  8 Bahrain     Asia      <tibble [12 × 4]>\n#>  9 Bangladesh  Asia      <tibble [12 × 4]>\n#> 10 Belgium     Europe    <tibble [12 × 4]>\n#> # … with 132 more rows\n```\n:::\n\n\n(I'm cheating a little by grouping on both `continent` and `country`. Given `country`, `continent` is fixed, so this doesn't add any more groups, but it's an easy way to carry an extra variable along for the ride.)\n\nThis creates a data frame that has one row per group (per country), and a rather unusual column: `data`. `data` is a list of data frames (or tibbles, to be precise).  This seems like a crazy idea: we have a data frame with a column that is a list of other data frames! I'll explain shortly why I think this is a good idea.\n\nThe `data` column is a little tricky to look at because it's a moderately complicated list, and we're still working on good tools to explore these objects. Unfortunately using `str()` is not recommended as it will often produce very long output. But if you pluck out a single element from the `data` column you'll see that it contains all the data for that country (in this case, Afghanistan).\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-9_8d4fea0867420a2fefe97b6580e4e5be'}\n\n```{.r .cell-code}\nby_country$data[[1]]\n#> # A tibble: 12 × 4\n#>     year lifeExp      pop gdpPercap\n#>    <int>   <dbl>    <int>     <dbl>\n#>  1  1952    28.8  8425333      779.\n#>  2  1957    30.3  9240934      821.\n#>  3  1962    32.0 10267083      853.\n#>  4  1967    34.0 11537966      836.\n#>  5  1972    36.1 13079460      740.\n#>  6  1977    38.4 14880372      786.\n#>  7  1982    39.9 12881816      978.\n#>  8  1987    40.8 13867957      852.\n#>  9  1992    41.7 16317921      649.\n#> 10  1997    41.8 22227415      635.\n#> 11  2002    42.1 25268405      727.\n#> 12  2007    43.8 31889923      975.\n```\n:::\n\n\nNote the difference between a standard grouped data frame and a nested data frame: in a grouped data frame, each row is an observation; in a nested data frame, each row is a group. Another way to think about a nested dataset is we now have a meta-observation: a row that represents the complete time course for a country, rather than a single point in time.\n\n### List-columns\n\nNow that we have our nested data frame, we're in a good position to fit some models. We have a model-fitting function:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-10_64a76b96fa6c7b356edac37e78cd41e0'}\n\n```{.r .cell-code}\ncountry_model <- function(df) {\n  lm(lifeExp ~ year, data = df)\n}\n```\n:::\n\n\nAnd we want to apply it to every data frame. The data frames are in a list, so we can use `purrr::map()` to apply `country_model` to each element:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-11_bc3c5e98ba55e9a5ca853844c95293af'}\n\n```{.r .cell-code}\nmodels <- map(by_country$data, country_model)\n```\n:::\n\n\nHowever, rather than leaving the list of models as a free-floating object, I think it's better to store it as a column in the `by_country` data frame. Storing related objects in columns is a key part of the value of data frames, and why I think list-columns are such a good idea. In the course of working with these countries, we are going to have lots of lists where we have one element per country. So why not store them all together in one data frame?\n\nIn other words, instead of creating a new object in the global environment, we're going to create a new variable in the `by_country` data frame. That's a job for `dplyr::mutate()`:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-12_290ff8735e10dce4997cd3751707c272'}\n\n```{.r .cell-code}\nby_country <- by_country %>% \n  mutate(model = map(data, country_model))\nby_country\n#> # A tibble: 142 × 4\n#> # Groups:   country, continent [142]\n#>    country     continent data              model \n#>    <fct>       <fct>     <list>            <list>\n#>  1 Afghanistan Asia      <tibble [12 × 4]> <lm>  \n#>  2 Albania     Europe    <tibble [12 × 4]> <lm>  \n#>  3 Algeria     Africa    <tibble [12 × 4]> <lm>  \n#>  4 Angola      Africa    <tibble [12 × 4]> <lm>  \n#>  5 Argentina   Americas  <tibble [12 × 4]> <lm>  \n#>  6 Australia   Oceania   <tibble [12 × 4]> <lm>  \n#>  7 Austria     Europe    <tibble [12 × 4]> <lm>  \n#>  8 Bahrain     Asia      <tibble [12 × 4]> <lm>  \n#>  9 Bangladesh  Asia      <tibble [12 × 4]> <lm>  \n#> 10 Belgium     Europe    <tibble [12 × 4]> <lm>  \n#> # … with 132 more rows\n```\n:::\n\n\nThis has a big advantage: because all the related objects are stored together, you don't need to manually keep them in sync when you filter or arrange. The semantics of the data frame takes care of that for you:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-13_eb34a6390d7d26b87d93852a737b52df'}\n\n```{.r .cell-code}\nby_country %>% \n  filter(continent == \"Europe\")\n#> # A tibble: 30 × 4\n#> # Groups:   country, continent [30]\n#>    country                continent data              model \n#>    <fct>                  <fct>     <list>            <list>\n#>  1 Albania                Europe    <tibble [12 × 4]> <lm>  \n#>  2 Austria                Europe    <tibble [12 × 4]> <lm>  \n#>  3 Belgium                Europe    <tibble [12 × 4]> <lm>  \n#>  4 Bosnia and Herzegovina Europe    <tibble [12 × 4]> <lm>  \n#>  5 Bulgaria               Europe    <tibble [12 × 4]> <lm>  \n#>  6 Croatia                Europe    <tibble [12 × 4]> <lm>  \n#>  7 Czech Republic         Europe    <tibble [12 × 4]> <lm>  \n#>  8 Denmark                Europe    <tibble [12 × 4]> <lm>  \n#>  9 Finland                Europe    <tibble [12 × 4]> <lm>  \n#> 10 France                 Europe    <tibble [12 × 4]> <lm>  \n#> # … with 20 more rows\nby_country %>% \n  arrange(continent, country)\n#> # A tibble: 142 × 4\n#> # Groups:   country, continent [142]\n#>    country                  continent data              model \n#>    <fct>                    <fct>     <list>            <list>\n#>  1 Algeria                  Africa    <tibble [12 × 4]> <lm>  \n#>  2 Angola                   Africa    <tibble [12 × 4]> <lm>  \n#>  3 Benin                    Africa    <tibble [12 × 4]> <lm>  \n#>  4 Botswana                 Africa    <tibble [12 × 4]> <lm>  \n#>  5 Burkina Faso             Africa    <tibble [12 × 4]> <lm>  \n#>  6 Burundi                  Africa    <tibble [12 × 4]> <lm>  \n#>  7 Cameroon                 Africa    <tibble [12 × 4]> <lm>  \n#>  8 Central African Republic Africa    <tibble [12 × 4]> <lm>  \n#>  9 Chad                     Africa    <tibble [12 × 4]> <lm>  \n#> 10 Comoros                  Africa    <tibble [12 × 4]> <lm>  \n#> # … with 132 more rows\n```\n:::\n\n\nIf your list of data frames and list of models were separate objects, you have to remember that whenever you re-order or subset one vector, you need to re-order or subset all the others in order to keep them in sync. If you forget, your code will continue to work, but it will give the wrong answer!\n\n### Unnesting\n\nPreviously we computed the residuals of a single model with a single dataset. Now we have 142 data frames and 142 models. To compute the residuals, we need to call `augment()` with each model pair:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-14_9ac5aa978a8091b63a9a551404452704'}\n\n```{.r .cell-code}\nby_country <- by_country %>% \n  mutate(\n    results = map(model, augment)\n  )\nby_country\n#> # A tibble: 142 × 5\n#> # Groups:   country, continent [142]\n#>    country     continent data              model  results          \n#>    <fct>       <fct>     <list>            <list> <list>           \n#>  1 Afghanistan Asia      <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  2 Albania     Europe    <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  3 Algeria     Africa    <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  4 Angola      Africa    <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  5 Argentina   Americas  <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  6 Australia   Oceania   <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  7 Austria     Europe    <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  8 Bahrain     Asia      <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#>  9 Bangladesh  Asia      <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#> 10 Belgium     Europe    <tibble [12 × 4]> <lm>   <tibble [12 × 8]>\n#> # … with 132 more rows\n```\n:::\n\n\nBut how can you plot a list of data frames? Instead of struggling to answer that question, let's turn the list of data frames back into a regular data frame. Previously we used `nest()` to turn a regular data frame into an nested data frame, and now we do the opposite with `unnest()`:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-15_dac9af647026b33256698116cb78dd11'}\n\n```{.r .cell-code}\nresids <- unnest(by_country, results)\nresids\n#> # A tibble: 1,704 × 12\n#> # Groups:   country, continent [142]\n#>    country    conti…¹ data     model lifeExp  year .fitted  .resid   .hat .sigma\n#>    <fct>      <fct>   <list>   <lis>   <dbl> <int>   <dbl>   <dbl>  <dbl>  <dbl>\n#>  1 Afghanist… Asia    <tibble> <lm>     28.8  1952    29.9 -1.11   0.295    1.21\n#>  2 Afghanist… Asia    <tibble> <lm>     30.3  1957    31.3 -0.952  0.225    1.24\n#>  3 Afghanist… Asia    <tibble> <lm>     32.0  1962    32.7 -0.664  0.169    1.27\n#>  4 Afghanist… Asia    <tibble> <lm>     34.0  1967    34.0 -0.0172 0.127    1.29\n#>  5 Afghanist… Asia    <tibble> <lm>     36.1  1972    35.4  0.674  0.0991   1.27\n#>  6 Afghanist… Asia    <tibble> <lm>     38.4  1977    36.8  1.65   0.0851   1.15\n#>  7 Afghanist… Asia    <tibble> <lm>     39.9  1982    38.2  1.69   0.0851   1.15\n#>  8 Afghanist… Asia    <tibble> <lm>     40.8  1987    39.5  1.28   0.0991   1.21\n#>  9 Afghanist… Asia    <tibble> <lm>     41.7  1992    40.9  0.754  0.127    1.26\n#> 10 Afghanist… Asia    <tibble> <lm>     41.8  1997    42.3 -0.534  0.169    1.27\n#> # … with 1,694 more rows, 2 more variables: .cooksd <dbl>, .std.resid <dbl>,\n#> #   and abbreviated variable name ¹​continent\n```\n:::\n\n\nNote that each regular column is repeated once for each row of the nested tibble.\n\nNow we have regular data frame, we can plot the residuals:\n\n\n::: {.cell layout-align=\"center\" hash='cache/resid-col-country_2c4f5aac18cc015b75b9190ec1728554'}\n\n```{.r .cell-code}\nresids %>% \n  ggplot(aes(year, .resid)) +\n    geom_line(aes(group = country), alpha = 1 / 3) + \n    geom_smooth(se = FALSE)\n#> `geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs =\n#> \"cs\")'\n```\n\n::: {.cell-output-display}\n![](figs/resid-col-country-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\nFacetting by continent is particularly revealing:\n \n\n::: {.cell layout-align=\"center\" hash='cache/resid-col-country-facetting_14d0637611062dbe6c16304bcf2c5b9a'}\n\n```{.r .cell-code}\nresids %>% \n  ggplot(aes(year, .resid, group = country)) +\n    geom_line(alpha = 1 / 3) + \n    facet_wrap(~continent)\n```\n\n::: {.cell-output-display}\n![](figs/resid-col-country-facetting-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\nIt looks like we've missed some mild patterns. There's also something interesting going on in Africa: we see some very large residuals which suggests our model isn't fitting so well there. We'll explore that more in the next section, attacking it from a slightly different angle.\n\n### Model quality\n\nInstead of looking at the residuals from the model, we could look at some general measurements of model quality. You learned how to compute some specific measures in the previous chapter. Here we'll show a different approach using the broom package and we'll use `broom::glance()` to extract some model quality metrics. If we apply it to a model, we get a data frame with a single row:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-18_29fbf5cd328907283445f10a58d7920e'}\n\n```{.r .cell-code}\nbroom::glance(nz_mod)\n#> # A tibble: 1 × 12\n#>   r.squ…¹ adj.r…² sigma stati…³ p.value    df logLik   AIC   BIC devia…⁴ df.re…⁵\n#>     <dbl>   <dbl> <dbl>   <dbl>   <dbl> <dbl>  <dbl> <dbl> <dbl>   <dbl>   <int>\n#> 1   0.954   0.949 0.804    205. 5.41e-8     1  -13.3  32.6  34.1    6.47      10\n#> # … with 1 more variable: nobs <int>, and abbreviated variable names\n#> #   ¹​r.squared, ²​adj.r.squared, ³​statistic, ⁴​deviance, ⁵​df.residual\n```\n:::\n\n\nWe can use `mutate()` and `unnest()` to create a data frame with a row for each country:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-19_f0d129ad2719cc5c9d7ebe4ebe270d50'}\n\n```{.r .cell-code}\nby_country %>% \n  mutate(glance = map(model, broom::glance)) %>% \n  unnest(glance)\n#> # A tibble: 142 × 17\n#> # Groups:   country, continent [142]\n#>    country     continent data     model  results  r.squa…¹ adj.r…² sigma stati…³\n#>    <fct>       <fct>     <list>   <list> <list>      <dbl>   <dbl> <dbl>   <dbl>\n#>  1 Afghanistan Asia      <tibble> <lm>   <tibble>    0.948   0.942 1.22    181. \n#>  2 Albania     Europe    <tibble> <lm>   <tibble>    0.911   0.902 1.98    102. \n#>  3 Algeria     Africa    <tibble> <lm>   <tibble>    0.985   0.984 1.32    662. \n#>  4 Angola      Africa    <tibble> <lm>   <tibble>    0.888   0.877 1.41     79.1\n#>  5 Argentina   Americas  <tibble> <lm>   <tibble>    0.996   0.995 0.292  2246. \n#>  6 Australia   Oceania   <tibble> <lm>   <tibble>    0.980   0.978 0.621   481. \n#>  7 Austria     Europe    <tibble> <lm>   <tibble>    0.992   0.991 0.407  1261. \n#>  8 Bahrain     Asia      <tibble> <lm>   <tibble>    0.967   0.963 1.64    291. \n#>  9 Bangladesh  Asia      <tibble> <lm>   <tibble>    0.989   0.988 0.977   930. \n#> 10 Belgium     Europe    <tibble> <lm>   <tibble>    0.995   0.994 0.293  1822. \n#> # … with 132 more rows, 8 more variables: p.value <dbl>, df <dbl>,\n#> #   logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>,\n#> #   nobs <int>, and abbreviated variable names ¹​r.squared, ²​adj.r.squared,\n#> #   ³​statistic\n```\n:::\n\n\nThis isn't quite the output we want, because it still includes all the list columns. This is default behaviour when `unnest()` works on single row data frames. To suppress these columns we use `select()`:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-20_d27b527c4581198609b7d833d613ff9f'}\n\n```{.r .cell-code}\nglance <- by_country %>% \n  mutate(glance = map(model, broom::glance)) %>% \n  unnest(glance) %>% \n  select(-data, -model, -results)\nglance\n#> # A tibble: 142 × 14\n#> # Groups:   country, continent [142]\n#>    country     conti…¹ r.squ…² adj.r…³ sigma stati…⁴  p.value    df logLik   AIC\n#>    <fct>       <fct>     <dbl>   <dbl> <dbl>   <dbl>    <dbl> <dbl>  <dbl> <dbl>\n#>  1 Afghanistan Asia      0.948   0.942 1.22    181.  9.84e- 8     1 -18.3  42.7 \n#>  2 Albania     Europe    0.911   0.902 1.98    102.  1.46e- 6     1 -24.1  54.3 \n#>  3 Algeria     Africa    0.985   0.984 1.32    662.  1.81e-10     1 -19.3  44.6 \n#>  4 Angola      Africa    0.888   0.877 1.41     79.1 4.59e- 6     1 -20.0  46.1 \n#>  5 Argentina   Americ…   0.996   0.995 0.292  2246.  4.22e-13     1  -1.17  8.35\n#>  6 Australia   Oceania   0.980   0.978 0.621   481.  8.67e-10     1 -10.2  26.4 \n#>  7 Austria     Europe    0.992   0.991 0.407  1261.  7.44e-12     1  -5.16 16.3 \n#>  8 Bahrain     Asia      0.967   0.963 1.64    291.  1.02e- 8     1 -21.9  49.7 \n#>  9 Bangladesh  Asia      0.989   0.988 0.977   930.  3.37e-11     1 -15.7  37.3 \n#> 10 Belgium     Europe    0.995   0.994 0.293  1822.  1.20e-12     1  -1.20  8.40\n#> # … with 132 more rows, 4 more variables: BIC <dbl>, deviance <dbl>,\n#> #   df.residual <int>, nobs <int>, and abbreviated variable names ¹​continent,\n#> #   ²​r.squared, ³​adj.r.squared, ⁴​statistic\n```\n:::\n\n\n(Pay attention to the variables that aren't printed: there's a lot of useful stuff there.)\n\nWith this data frame in hand, we can start to look for models that don't fit well:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-21_d83a1d55ca945dbc465db816ec04bfbf'}\n\n```{.r .cell-code}\nglance %>% \n  arrange(r.squared)\n#> # A tibble: 142 × 14\n#> # Groups:   country, continent [142]\n#>    country     conti…¹ r.squ…² adj.r.…³ sigma stati…⁴ p.value    df logLik   AIC\n#>    <fct>       <fct>     <dbl>    <dbl> <dbl>   <dbl>   <dbl> <dbl>  <dbl> <dbl>\n#>  1 Rwanda      Africa   0.0172 -0.0811   6.56   0.175  0.685      1  -38.5  83.0\n#>  2 Botswana    Africa   0.0340 -0.0626   6.11   0.352  0.566      1  -37.7  81.3\n#>  3 Zimbabwe    Africa   0.0562 -0.0381   7.21   0.596  0.458      1  -39.6  85.3\n#>  4 Zambia      Africa   0.0598 -0.0342   4.53   0.636  0.444      1  -34.1  74.1\n#>  5 Swaziland   Africa   0.0682 -0.0250   6.64   0.732  0.412      1  -38.7  83.3\n#>  6 Lesotho     Africa   0.0849 -0.00666  5.93   0.927  0.358      1  -37.3  80.6\n#>  7 Cote d'Ivo… Africa   0.283   0.212    3.93   3.95   0.0748     1  -32.3  70.7\n#>  8 South Afri… Africa   0.312   0.244    4.74   4.54   0.0588     1  -34.6  75.2\n#>  9 Uganda      Africa   0.342   0.276    3.19   5.20   0.0457     1  -29.8  65.7\n#> 10 Congo, Dem… Africa   0.348   0.283    2.43   5.34   0.0434     1  -26.6  59.2\n#> # … with 132 more rows, 4 more variables: BIC <dbl>, deviance <dbl>,\n#> #   df.residual <int>, nobs <int>, and abbreviated variable names ¹​continent,\n#> #   ²​r.squared, ³​adj.r.squared, ⁴​statistic\n```\n:::\n\n\nThe worst models all appear to be in Africa. Let's double check that with a plot. Here we have a relatively small number of observations and a discrete variable, so `geom_jitter()` is effective:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-22_b17e73e36f9d4742520ff132c9efdb12'}\n\n```{.r .cell-code}\nglance %>% \n  ggplot(aes(continent, r.squared)) + \n    geom_jitter(width = 0.5)\n```\n\n::: {.cell-output-display}\n![](figs/unnamed-chunk-22-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\nWe could pull out the countries with particularly bad $R^2$ and plot the data:\n\n\n::: {.cell layout-align=\"center\" hash='cache/bad-fit_13c41bcbbbf2d973e20cd72d72d0a3c5'}\n\n```{.r .cell-code}\nbad_fit <- filter(glance, r.squared < 0.25)\n\ngapminder %>% \n  semi_join(bad_fit, by = \"country\") %>% \n  ggplot(aes(year, lifeExp, colour = country)) +\n    geom_line()\n```\n\n::: {.cell-output-display}\n![](figs/bad-fit-1.svg){fig-align='center' width=672}\n:::\n:::\n\n\nWe see two main effects here: the tragedies of the HIV/AIDS epidemic and the Rwandan genocide.\n\n## List-columns\n\nNow that you've seen a basic workflow for managing many models, let's dive back into some of the details. In this section, we'll explore the list-column data structure in a little more detail. It's only recently that I've really appreciated the idea of the list-column. List-columns are implicit in the definition of the data frame: a data frame is a named list of equal length vectors. A list is a vector, so it's always been legitimate to use a list as a column of a data frame. However, base R doesn't make it easy to create list-columns, and `data.frame()` treats a list as a list of columns:.\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-24_97763c91d39b29a3f52f57ee8179a474'}\n\n```{.r .cell-code}\ndata.frame(x = list(1:3, 3:5))\n#>   x.1.3 x.3.5\n#> 1     1     3\n#> 2     2     4\n#> 3     3     5\n```\n:::\n\n\nYou can prevent `data.frame()` from doing this with `I()`, but the result doesn't print particularly well:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-25_fb3451cc239058315af5f7b64281bb29'}\n\n```{.r .cell-code}\ndata.frame(\n  x = I(list(1:3, 3:5)), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#>         x       y\n#> 1 1, 2, 3    1, 2\n#> 2 3, 4, 5 3, 4, 5\n```\n:::\n\n\nTibble alleviates this problem by being lazier (`tibble()` doesn't modify its inputs) and by providing a better print method:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-26_29701685194683f636ee283a989410c2'}\n\n```{.r .cell-code}\ntibble(\n  x = list(1:3, 3:5), \n  y = c(\"1, 2\", \"3, 4, 5\")\n)\n#> # A tibble: 2 × 2\n#>   x         y      \n#>   <list>    <chr>  \n#> 1 <int [3]> 1, 2   \n#> 2 <int [3]> 3, 4, 5\n```\n:::\n\n\nIt's even easier with `tribble()` as it can automatically work out that you need a list:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-27_52dbc2d077eb5bf7e84d8cd78ab0fe23'}\n\n```{.r .cell-code}\ntribble(\n   ~x, ~y,\n  1:3, \"1, 2\",\n  3:5, \"3, 4, 5\"\n)\n#> # A tibble: 2 × 2\n#>   x         y      \n#>   <list>    <chr>  \n#> 1 <int [3]> 1, 2   \n#> 2 <int [3]> 3, 4, 5\n```\n:::\n\n\nList-columns are often most useful as intermediate data structure. They're hard to work with directly, because most R functions work with atomic vectors or data frames, but the advantage of keeping related items together in a data frame is worth a little hassle.\n\nGenerally there are three parts of an effective list-column pipeline:\n\n1.  You create the list-column using one of `nest()`, `summarise()` + `list()`,\n    or `mutate()` + a map function, as described in [Creating list-columns].\n\n1.  You create other intermediate list-columns by transforming existing\n    list columns with `map()`, `map2()` or `pmap()`. For example, \n    in the case study above, we created a list-column of models by transforming\n    a list-column of data frames.\n    \n1.  You simplify the list-column back down to a data frame or atomic vector,\n    as described in [Simplifying list-columns].\n\n## Creating list-columns\n\nTypically, you won't create list-columns with `tibble()`. Instead, you'll create them from regular columns, using one of three methods: \n\n1.  With `tidyr::nest()` to convert a grouped data frame into a nested data \n    frame where you have list-column of data frames.\n    \n1.  With `mutate()` and vectorised functions that return a list.\n\n1.  With `summarise()` and summary functions that return multiple results. \n\nAlternatively, you might create them from a named list, using `tibble::enframe()`.\n\nGenerally, when creating list-columns, you should make sure they're homogeneous: each element should contain the same type of thing. There are no checks to make sure this is true, but if you use purrr and remember what you've learned about type-stable functions, you should find it happens naturally.\n\n### With nesting\n\n`nest()` creates a nested data frame, which is a data frame with a list-column of data frames. In a nested data frame each row is a meta-observation: the other columns give variables that define the observation (like country and continent above), and the list-column of data frames gives the individual observations that make up the meta-observation.\n\nThere are two ways to use `nest()`. So far you've seen how to use it with a grouped data frame. When applied to a grouped data frame, `nest()` keeps the grouping columns as is, and bundles everything else into the list-column:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-28_f11a57ba961e752149808dbd5ddaf183'}\n\n```{.r .cell-code}\ngapminder %>% \n  group_by(country, continent) %>% \n  nest()\n#> # A tibble: 142 × 3\n#> # Groups:   country, continent [142]\n#>    country     continent data             \n#>    <fct>       <fct>     <list>           \n#>  1 Afghanistan Asia      <tibble [12 × 4]>\n#>  2 Albania     Europe    <tibble [12 × 4]>\n#>  3 Algeria     Africa    <tibble [12 × 4]>\n#>  4 Angola      Africa    <tibble [12 × 4]>\n#>  5 Argentina   Americas  <tibble [12 × 4]>\n#>  6 Australia   Oceania   <tibble [12 × 4]>\n#>  7 Austria     Europe    <tibble [12 × 4]>\n#>  8 Bahrain     Asia      <tibble [12 × 4]>\n#>  9 Bangladesh  Asia      <tibble [12 × 4]>\n#> 10 Belgium     Europe    <tibble [12 × 4]>\n#> # … with 132 more rows\n```\n:::\n\n\nYou can also use it on an ungrouped data frame, specifying which columns you want to nest:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-29_ad45d8ba48d66c90e9ccb0470adb9866'}\n\n```{.r .cell-code}\ngapminder %>% \n  nest(data = c(year:gdpPercap))\n#> # A tibble: 142 × 3\n#>    country     continent data             \n#>    <fct>       <fct>     <list>           \n#>  1 Afghanistan Asia      <tibble [12 × 4]>\n#>  2 Albania     Europe    <tibble [12 × 4]>\n#>  3 Algeria     Africa    <tibble [12 × 4]>\n#>  4 Angola      Africa    <tibble [12 × 4]>\n#>  5 Argentina   Americas  <tibble [12 × 4]>\n#>  6 Australia   Oceania   <tibble [12 × 4]>\n#>  7 Austria     Europe    <tibble [12 × 4]>\n#>  8 Bahrain     Asia      <tibble [12 × 4]>\n#>  9 Bangladesh  Asia      <tibble [12 × 4]>\n#> 10 Belgium     Europe    <tibble [12 × 4]>\n#> # … with 132 more rows\n```\n:::\n\n\n### From vectorised functions\n\nSome useful functions take an atomic vector and return a list. For example, in [strings] you learned about `stringr::str_split()` which takes a character vector and returns a list of character vectors. If you use that inside mutate, you'll get a list-column:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-30_6772ea994865952a8e7fd26904022394'}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~x1,\n  \"a,b,c\", \n  \"d,e,f,g\"\n) \n\ndf %>% \n  mutate(x2 = stringr::str_split(x1, \",\"))\n#> # A tibble: 2 × 2\n#>   x1      x2       \n#>   <chr>   <list>   \n#> 1 a,b,c   <chr [3]>\n#> 2 d,e,f,g <chr [4]>\n```\n:::\n\n\n`unnest()` knows how to handle these lists of vectors:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-31_5383a0d2ba7df5eff168bb876a5d5ea8'}\n\n```{.r .cell-code}\ndf %>% \n  mutate(x2 = stringr::str_split(x1, \",\")) %>% \n  unnest(x2)\n#> # A tibble: 7 × 2\n#>   x1      x2   \n#>   <chr>   <chr>\n#> 1 a,b,c   a    \n#> 2 a,b,c   b    \n#> 3 a,b,c   c    \n#> 4 d,e,f,g d    \n#> 5 d,e,f,g e    \n#> 6 d,e,f,g f    \n#> 7 d,e,f,g g\n```\n:::\n\n\n(If you find yourself using this pattern a lot, make sure to check out `tidyr::separate_rows()` which is a wrapper around this common pattern).\n\n### From multivalued summaries\n\nOne restriction of `summarise()` is that it only works with summary functions that return a single value. That means that you can't use it with functions like `quantile()` that return a vector of arbitrary length:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-32_2d4fdca31406fbc4bb3e8f8a94dd5615'}\n\n```{.r .cell-code}\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = quantile(mpg), .groups = \"drop\")\n#> # A tibble: 15 × 2\n#>      cyl     q\n#>    <dbl> <dbl>\n#>  1     4  21.4\n#>  2     4  22.8\n#>  3     4  26  \n#>  4     4  30.4\n#>  5     4  33.9\n#>  6     6  17.8\n#>  7     6  18.6\n#>  8     6  19.7\n#>  9     6  21  \n#> 10     6  21.4\n#> 11     8  10.4\n#> 12     8  14.4\n#> 13     8  15.2\n#> 14     8  16.2\n#> 15     8  19.2\n```\n:::\n\n\nYou can however, wrap the result in a list! This obeys the contract of `summarise()`, because each summary is now a list (a vector) of length 1.\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-33_7253c1101e122f8878b4a515c4d52a44'}\n\n```{.r .cell-code}\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(q = list(quantile(mpg)), .groups = \"drop\")\n#> # A tibble: 3 × 2\n#>     cyl q        \n#>   <dbl> <list>   \n#> 1     4 <dbl [5]>\n#> 2     6 <dbl [5]>\n#> 3     8 <dbl [5]>\n```\n:::\n\n\nTo make useful results with unnest, you'll also need to capture the probabilities:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-34_6afbf2872d9c478036eb13c03d34f396'}\n\n```{.r .cell-code}\nprobs <- c(0.01, 0.25, 0.5, 0.75, 0.99)\nmtcars %>% \n  group_by(cyl) %>% \n  summarise(p = list(probs), q = list(quantile(mpg, probs)), .groups = \"drop\") %>% \n  unnest(c(p, q))\n#> # A tibble: 15 × 3\n#>      cyl     p     q\n#>    <dbl> <dbl> <dbl>\n#>  1     4  0.01  21.4\n#>  2     4  0.25  22.8\n#>  3     4  0.5   26  \n#>  4     4  0.75  30.4\n#>  5     4  0.99  33.8\n#>  6     6  0.01  17.8\n#>  7     6  0.25  18.6\n#>  8     6  0.5   19.7\n#>  9     6  0.75  21  \n#> 10     6  0.99  21.4\n#> 11     8  0.01  10.4\n#> 12     8  0.25  14.4\n#> 13     8  0.5   15.2\n#> 14     8  0.75  16.2\n#> 15     8  0.99  19.1\n```\n:::\n\n\n### From a named list\n\nData frames with list-columns provide a solution to a common problem: what do you do if you want to iterate over both the contents of a list and its elements? Instead of trying to jam everything into one object, it's often easier to make a data frame: one column can contain the elements, and one column can contain the list.  An easy way to create such a data frame from a list is `tibble::enframe()`.  \n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-35_07316fc9ee6eadc2cd59054abbcd06b5'}\n\n```{.r .cell-code}\nx <- list(\n  a = 1:5,\n  b = 3:4, \n  c = 5:6\n) \n\ndf <- enframe(x)\ndf\n#> # A tibble: 3 × 2\n#>   name  value    \n#>   <chr> <list>   \n#> 1 a     <int [5]>\n#> 2 b     <int [2]>\n#> 3 c     <int [2]>\n```\n:::\n\n\nThe advantage of this structure is that it generalises in a straightforward way - names are useful if you have character vector of metadata, but don't help if you have other types of data, or multiple vectors.\n\nNow if you want to iterate over names and values in parallel, you can use `map2()`:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-36_dab9f369fd520608f3cb046d69335c92'}\n\n```{.r .cell-code}\ndf %>% \n  mutate(\n    smry = map2_chr(name, value, ~ stringr::str_c(.x, \": \", .y[1]))\n  )\n#> # A tibble: 3 × 3\n#>   name  value     smry \n#>   <chr> <list>    <chr>\n#> 1 a     <int [5]> a: 1 \n#> 2 b     <int [2]> b: 3 \n#> 3 c     <int [2]> c: 5\n```\n:::\n\n\n## Simplifying list-columns\n\nTo apply the techniques of data manipulation and visualisation, you'll need to simplify the list-column back to a regular column (an atomic vector), or set of columns. The technique you'll use to collapse back down to a simpler structure depends on whether you want a single value per element, or multiple values:\n\n1.  If you want a single value, use `mutate()` with `map_lgl()`, \n    `map_int()`, `map_dbl()`, and `map_chr()` to create an atomic vector.\n    \n1.  If you want many values, use `unnest()` to convert list-columns back\n    to regular columns, repeating the rows as many times as necessary.\n\nThese are described in more detail below.\n\n### List to vector\n\nIf you can reduce your list column to an atomic vector then it will be a regular column. For example, you can always summarise an object with its type and length, so this code will work regardless of what sort of list-column you have:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-37_26a70c17974bd1d905cfc9be32c9bc5a'}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~x,\n  letters[1:5],\n  1:3,\n  runif(5)\n)\n  \ndf %>% mutate(\n  type = map_chr(x, typeof),\n  length = map_int(x, length)\n)\n#> # A tibble: 3 × 3\n#>   x         type      length\n#>   <list>    <chr>      <int>\n#> 1 <chr [5]> character      5\n#> 2 <int [3]> integer        3\n#> 3 <dbl [5]> double         5\n```\n:::\n\n\nThis is the same basic information that you get from the default tbl print method, but now you can use it for filtering. This is a useful technique if you have a heterogeneous list, and want to filter out the parts aren't working for you.\n\nDon't forget about the `map_*()` shortcuts - you can use `map_chr(x, \"apple\")` to extract the string stored in `apple` for each element of `x`. This is useful for pulling apart nested lists into regular columns. Use the `.null` argument to provide a value to use if the element is missing (instead of returning `NULL`):\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-38_371e20614dbdc88361691abd40e06efa'}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~x,\n  list(a = 1, b = 2),\n  list(a = 2, c = 4)\n)\ndf %>% mutate(\n  a = map_dbl(x, \"a\"),\n  b = map_dbl(x, \"b\", .null = NA_real_)\n)\n#> # A tibble: 2 × 3\n#>   x                    a     b\n#>   <list>           <dbl> <dbl>\n#> 1 <named list [2]>     1     2\n#> 2 <named list [2]>     2    NA\n```\n:::\n\n\n### Unnesting\n\n`unnest()` works by repeating the regular columns once for each element of the list-column. For example, in the following very simple example we repeat the first row 4 times (because there the first element of `y` has length four), and the second row once:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-39_9258557f61c71bc301193592c32d83e3'}\n\n```{.r .cell-code}\ntibble(x = 1:2, y = list(1:4, 1)) %>% unnest(y)\n#> # A tibble: 5 × 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     1\n#> 2     1     2\n#> 3     1     3\n#> 4     1     4\n#> 5     2     1\n```\n:::\n\n\nThis means that you can't simultaneously unnest two columns that contain different number of elements:\n\n\n::: {.cell layout-align=\"center\" hash='cache/unnamed-chunk-40_064f99a9fac9f6b66f927549a87cadf9'}\n\n```{.r .cell-code}\n# Ok, because y and z have the same number of elements in\n# every row\ndf1 <- tribble(\n  ~x, ~y,           ~z,\n   1, c(\"a\", \"b\"), 1:2,\n   2, \"c\",           3\n)\ndf1\n#> # A tibble: 2 × 3\n#>       x y         z        \n#>   <dbl> <list>    <list>   \n#> 1     1 <chr [2]> <int [2]>\n#> 2     2 <chr [1]> <dbl [1]>\ndf1 %>% unnest(c(y, z))\n#> # A tibble: 3 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 a         1\n#> 2     1 b         2\n#> 3     2 c         3\n\n# Doesn't work because y and z have different number of elements\ndf2 <- tribble(\n  ~x, ~y,           ~z,\n   1, \"a\",         1:2,  \n   2, c(\"b\", \"c\"),   3\n)\ndf2\n#> # A tibble: 2 × 3\n#>       x y         z        \n#>   <dbl> <list>    <list>   \n#> 1     1 <chr [1]> <int [2]>\n#> 2     2 <chr [2]> <dbl [1]>\ndf2 %>% unnest(c(y, z))\n#> # A tibble: 4 × 3\n#>       x y         z\n#>   <dbl> <chr> <dbl>\n#> 1     1 a         1\n#> 2     1 a         2\n#> 3     2 b         3\n#> 4     2 c         3\n```\n:::\n\n\nThe same principle applies when unnesting list-columns of data frames. You can unnest multiple list-cols as long as all the data frames in each row have the same number of rows.\n\n\n## Making tidy data with broom\n\nThe broom package provides three general tools for turning models into tidy data frames:\n\n1.  `broom::glance(model)` returns a row for each model. Each column gives a \n    model summary: either a measure of model quality, or complexity, or a \n    combination of the two.\n   \n1.  `broom::tidy(model)` returns a row for each coefficient in the model. Each \n    column gives information about the estimate or its variability.\n    \n1.  `broom::augment(model, data)` returns a row for each row in `data`, adding\n    extra values like residuals, and influence statistics.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}